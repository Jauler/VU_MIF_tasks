<html>
<h1>Rytis Karpu≈°ka A* example</h1>

<p>Dimensions of the map</p>
<input id="x" type="number" min="2" max="30" value="15"/>
<input id="y" type="number" min="2" max="30" value="15"/>
<button type="button" onclick="drawBoard();">Draw board</button>
<br>
<p>Click on the map creates:
<input type="radio" name="clickFunc" value="empty">Empty
<input type="radio" name="clickFunc" value="wall" checked="checked">Wall
<input type="radio" name="clickFunc" value="start">Start
<input type="radio" name="clickFunc" value="end">End
</p>

<button type="button" onClick="startRequest();">Start</button>
<button type="stop" onClick="stopRequest();">Stop</button>
<br><br>
<canvas id="myCanvas" width=1000 height=1000" onclick="gridOnClick(event);">
This browser does not support canvas
</canvas>

<br>
<br>
<script>

//declare point type
function Point(){
	var x = INVALID;
	var y = INVALID;
}

var runned = 0;
var running = 0;
var stopRequestActive = 0;
var openset;
var closedset = new Array;
var f_score = new Array;
var g_score = new Array;
var come_from = new Array;


//constants
var INVALID = -1;
var EMPTY = 0;
var WALL = 1;
var START = 2;
var END = 3;
var OPENSET = 4;
var CLOSEDSET = 5;
var PATH = 6;

//TODO: review
var neighbor = [{x: 0, y: 1}, {x:1, y:0}, {x:0, y:-1}, {x:-1, y:0},
		{x: -1, y: -1}, {x: 1, y:1}, {x: -1, y: 1}, {x:1, y:-1}]

//Our map
var map = new Array;

//Map size
var xSize = 0;
var ySize = 0;

//Start coordinates
var start = new Point;

//End coordinates
var end = new Point;

//The size of the square
var tileSize = 20;


function drawBoard(){
    start.x = INVALID;
    start.y = INVALID;
    end.x = INVALID;
    end.y = INVALID;
    runned = 0;
    openset = new Array;
    closedset = new Array;

    var canvas =  document.getElementById("myCanvas");
    var context = canvas.getContext("2d");

    //Get dimensions of the map
    var bw = document.getElementById("x").value;
    var bh = document.getElementById("y").value;

    //validate size
    if(bw < 2){
        alert("Tile world width should be more than 1");
        return;
    }
    if(bw > 40){
        alert("Maximum allowed tile world width is 40");
        return;
    }
    if(bh < 2){
        alert("Tile world width should be more than 1");
        return;
    }
    if(bw > 40){
        alert("Maximum allowed tile world width is 40");
    }

    //Create an array to work in
    map = new Array(bw);
    for(var i = 0; i < bw; i++)
        map[i] = new Array(bh);

    //Array for g_scores
    g_score = new Array(bw);
    for(var i = 0; i < bw; i++)
        g_score[i] = new Array(bh);

    //Array for f_scores
    f_score = new Array(bw);
    for(var i = 0; i < bw; i++)
        f_score[i] = new Array(bh);

    come_from = new Array(bw);
    for(var i = 0; i < bw; i++){
        come_from[i] = new Array(bh);
        for(var j = 0; j < bh; j++){
            come_from[i][j] = new Point;
            come_from[i][j].x = INVALID;
            come_from[i][j].y = INVALID;
        }
    }

    //clear whatever was in hear
    context.clearRect(0, 0, 1000, 500);
    context.beginPath();

    for (var x = 0; x <= bw * tileSize; x += tileSize) {
        context.moveTo(0.5 + x, 0);
        context.lineTo(0.5 + x, bh * tileSize);
    }


    for (var x = 0; x <= bh * tileSize; x += tileSize) {
        context.moveTo(0, 0.5 + x);
        context.lineTo(bw * tileSize, 0.5 + x);
    }

    context.strokeStyle = "black";
    context.stroke();

    xSize = bw;
    ySize = bh;
}
function clearBoard(){
    //Get dimensions of the map
    document.getElementById("x").value = xSize;
    document.getElementById("y").value = ySize;

    drawBoard();
}

function getCheckedRadioId(name) {
    var elements = document.getElementsByName(name);

    for (var i=0, len=elements.length; i<len; ++i)
        if (elements[i].checked) return elements[i].value;
}

function colorTile(x, y, type)
{
    var canvas = document.getElementById('myCanvas').getContext("2d");
    switch(type){
    case EMPTY:
        canvas.fillStyle="#FFFFFF";  //White
        break;
    case WALL:
        canvas.fillStyle="#0000AA";  //Blue
        break;
    case START:
        canvas.fillStyle="#00AA00";  //Green
        break;
    case END:
        canvas.fillStyle="#AA0000";  //Red
        break;
    case OPENSET:
        canvas.fillStyle="#AAAA00"; //Yellow
        break;
    case CLOSEDSET:
        canvas.fillStyle="#888888"; //grey
        break;
    case PATH:
        canvas.fillStyle="#333333" //dark grey
    }

    canvas.fillRect(x * tileSize + 1, y * tileSize + 1, tileSize - 1, tileSize - 1);

    return;
}

function clearOldAlgorithm(){
	for(var i = 0; i < xSize; i++)
		for(var j = 0; j < ySize; j++){
			if(map[i][j] == OPENSET ||
					map[i][j] == CLOSEDSET ||
					map[i][j] == PATH){
				map[i][j] = EMPTY;
				colorTile(i, j, EMPTY);
			}
		}
}


function gridOnClick(event) {
    if(running)
        return;//Do not let edit map while running

    if(runned){
        clearOldAlgorithm();
        runned = 0;
    }

    event = event || window.event;

    var canvas = document.getElementById('myCanvas');
    x = event.pageX - canvas.offsetLeft;
    y = event.pageY - canvas.offsetTop;

    tile = new Point();

    tile.x = Math.floor(x / tileSize);
    tile.y = Math.floor(y / tileSize);

    if(tile.x >= xSize || tile.y >= ySize)
        return;

    switch(getCheckedRadioId("clickFunc")){
    case "empty":
        if(start.x == tile.x && start.y == tile.y){
            start.x = INVALID;
            start.y = INVALID;
        } else if(end.x == tile.x && end.y == tile.y){
            end.x = INVALID;
            end.y = INVALID;
        }

        map[tile.x][tile.y] = EMPTY;
        colorTile(tile.x, tile.y, EMPTY);

        break;
    case "wall":
        if(start.x == tile.x && ySize == tilei.y){
            start.x = INVALID;
            start.y = INVALID;
        } else if(end.x == tile.x && end.y == tile.y){
            end.x = INVALID;
            end.y = INVALID;
        }

        map[tile.x][tile.y] = WALL;
        colorTile(tile.x, tile.y, WALL);

        break;

    case "start":
        if(start.x != INVALID && start.y != INVALID){
            map[start.x][start.y] = EMPTY;
            colorTile(start.x, start.y, EMPTY);
        }
        if(end.x == tile.x && end.y == tile.y){
            end.x = INVALID;
            end.y = INVALID;
        }

        map[tile.x][tile.y] = START;
        start.x = tile.x;
        start.y = tile.y;
        colorTile(tile.x, tile.y, START);

        break;

    case "end":
        if(end.x != INVALID && end.y != INVALID){
            map[end.x][end.y] = EMPTY;
            colorTile(end.x, end.y, EMPTY);
        }
        if(start.x == tile.x && ySize == tile.y){
            start.x = INVALID;
            start.y = INVALID;
        }

        map[tile.x][tile.y] = END;
        end.x = tile.x;
        end.y = tile.y;
        colorTile(tile.x, tile.y, END);

        break;
    }

}

function dist(x1, y1, x2, y2)
{
	return Math.sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
}

function lowestFScore(openset)
{
	//Search lowest
	var lowestCoord = new Point;
	lowestCoord = openset[0];
	var lowestValue = f_score[openset[0].x][openset[0].y];
	var idx = 0;
	for(var i = 1; i < openset.length; i++){
		if(f_score[openset[i].x][openset[i].y] < lowestValue){
			lowestValue = f_score[openset[i].x][openset[i].y];
			lowestCoord = openset[i];
			idx = i;
		}
	}

	return {"point": lowestCoord, "idx":idx};
}

function myIndexOf(arr, obj)
{
	for(var i = 0; i < arr.length; i++){
		if(JSON.stringify(arr[i]) == JSON.stringify(obj))
			return i;
	}

	return -1;
}

function reconstruct_path(current_node)
{
	if( (current_node.x != start.x || current_node.y != start.y) &&
			(current_node.x != end.x || current_node.y != end.y)){
		colorTile(current_node.x, current_node.y, PATH);
		map[current_node.x][current_node.y] = PATH;
	}

	if(come_from[current_node.x][current_node.y].x == INVALID ||
		come_from[current_node.x][current_node.y].y == INVALID){
		return;
	} else {
		tmpPoint = new Point;
		tmpPoint.x = come_from[current_node.x][current_node.y].x
		tmpPoint.y = come_from[current_node.x][current_node.y].y;
		reconstruct_path(tmpPoint);
		return;
	}

}

function searchPath()
{
	//Check for stop request
	if(stopRequestActive){
		running = 0;
		stopRequestActive = 0;
		runned = 1;
		return;
	} else {
		setTimeout(searchPath, 100);
	}

	//check if our openset has anything
	if(openset.length <= 0){
		stopRequestActive = 1;
		alert("Could not found path");
		return;
	}

	//Get coordinates for current node
	current = lowestFScore(openset);

	//check if this is not the goal node
	if(current.point.x == end.x && current.point.y == end.y){
		stopRequestActive = 1;
		reconstruct_path(end);
		alert("goal Reached");
		return;
	}

	//Removing current from openset and adding to the closedset
	openset.splice(current.idx, 1);
	closedset.push(current.point);
	if(current.point.x != start.x || current.point.y != start.y){
		colorTile(current.point.x, current.point.y, CLOSEDSET);
		map[current.point.x][current.point.y] = CLOSEDSET;
	}

	for(var i = 0; i < neighbor.length; i++){
		myPoint = new Point;
		myPoint.x = current.point.x + neighbor[i].x
		myPoint.y = current.point.y + neighbor[i].y;

		//Physical map restrictions
		if(myPoint.x >= xSize || myPoint.y >= ySize)
			continue;
		if(myPoint.x < 0 || myPoint.y < 0)
			continue;
		if(map[myPoint.x][myPoint.y] == WALL)
			continue;


		if(myIndexOf(closedset, myPoint) >= 0)
			continue;

		tent_g_score = g_score[current.point.x][current.point.y] +
			dist(current.point.x, current.point.y, myPoint.x, myPoint.y);

		if(myIndexOf(openset, myPoint) < 0 ||
				tent_g_score < g_score[myPoint.x][myPoint.y]){
			come_from[myPoint.x][myPoint.y] = current.point;
			g_score[myPoint.x][myPoint.y] = tent_g_score;
			f_score[myPoint.x][myPoint.y] = g_score[myPoint.x][myPoint.y] + 
						dist(myPoint.x, myPoint.y, end.x, end.y);

			if(myIndexOf(openset, myPoint) < 0){
				openset.push(myPoint);
				if(myPoint.x != end.x || myPoint.y != end.y){
					colorTile(myPoint.x, myPoint.y, OPENSET);
					map[myPoint.x][myPoint.y] = OPENSET;
				}
			}

		}

	}

	return;
}





function stopRequest(){
	if(running){
		running = 0;
		stopRequestActive = 1;
	}

    return;
}

function startRequest(){
	if(start.x == INVALID || start.y == INVALID){
		alert("Please select the start node");
		return;
	}
	if(end.x == INVALID || end.y == INVALID){
		alert("Please select the finish node");
		return;
	}

	//Init variables
	running = 1;
	stopRequestActive = 0;
	g_score[start.x][start.y] = 0;
	f_score[start.x][start.y] = dist(start.x, start.y, end.x, end.y);

	//add start to openset
	openset.push(start);

	setTimeout(searchPath, 500);
}


</script>




</html>
